package models;

import shared.Constants;
import shared.HelperFunctions;

import java.security.SecureRandom;
import java.util.Random;

public class KeyManager {

    private static final int[] Rcon = Constants.RCON;
    private static final int blockSizeInWords = Constants.blockSizeInWords;  // Block size in words (4 words = 16 bytes = 128 bits)
    private static final int blockSizeInBytes = Constants.blockSizeInBytes; // AES block size is 16 bytes (128 bits)
    private static final int keyLengthInWords = Constants.keyLengthInWords;  // Key length in words (AES-128 uses 4 words = 128 bits)
    private static final int numberOfRounds = Constants.numberOfRounds;   // Number of rounds of encryption (10 for AES-128)


    /**
     * Generates a secure random AES key of the specified length.
     *
     * @param keyLength (Length of key in bytes, using 16 for AES128)
     * @return a byte array - randomly generated AES key
     */
    public static byte[] generateRandomKey(int keyLength) {
        byte[] key = new byte[keyLength];
        SecureRandom random = new SecureRandom();
        random.nextBytes(key);
        return key;
    }

    /**
     * Generates a random Initialization Vector (IV)
     *
     * @return A randomly generated byte array of size equal to the AES block size
     */
    public static byte[] generateRandomIV() {
        byte[] iv = new byte[blockSizeInBytes];
        new Random().nextBytes(iv);
        return iv;
    }

    /**
     * Generates the AES Key Schedule (Round Keys) for AES encryption and decryption.
     *
     * 1. Copy the original key into the first 4 words of the keySchedule.
     * 2. Starting from position keyLengthInWords, for each next word:
     * - If index of word is multiple of keyLengthInWords (4) perform:
     *   Rotate word, substitute bytes, XOR with Rcon in that order
     * - Otherwise, XOR the word with the word that 4 positions earlier
     *
     * @param key (A 16-bytes or 4 word array representing the AES key)
     * @return keySchedule (A 2D byte array, with 11 sets of 16-byte round keys)
     */
    public static byte[][] generateKeySchedule(byte[] key) {
        // Initialize a 2D array to hold the keys
        // Each round key is 4 words.
        // We need numberOfRounds + 1 round keys because initial key and 10 rounds of encryption
        byte[][] keySchedule = new byte[blockSizeInWords * (numberOfRounds + 1)][4];

        // Copy the original key into the first 4 words
        for (int i = 0; i < keyLengthInWords; i++) {
            for (int j = 0; j < 4; j++) {
                keySchedule[i][j] = key[i * 4 + j];
            }
        }
        // Generate the remaining keys for 10 rounds
        // Starting from position keyLengthInWords, loop goes through 40 words
        for (int i = keyLengthInWords; i < blockSizeInWords * (numberOfRounds + 1); i++) {
            byte[] temp = keySchedule[i - 1].clone();
            // temp is initialized with the previous word
            if (i % keyLengthInWords == 0) {
                // For every word that is multiple of 4 (it is the first word in a block of words)
                // Performs rotate word, substitute bytes, XOR with Rcon in that order
                temp = HelperFunctions.xor_func(HelperFunctions.subWord(HelperFunctions.rotateWord(temp)), new byte[]{(byte) Rcon[(i / keyLengthInWords) - 1], 0, 0, 0});
            }
            for (int j = 0; j < 4; j++) {
                // Words that are not divisible by keyLengthInWords (4), are derived
                // by XORing the word that is 4 positions earlier with the temp
                // This operation is also mandatory for words multiple of 4 but comes after the other three manipulations
                keySchedule[i][j] = (byte) (keySchedule[i - keyLengthInWords][j] ^ temp[j]);
            }
        }
        return keySchedule;
    }

}
